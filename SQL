/* Запрос, который оставит в поле phone только цифры: */

SELECT REGEXP_REPLACE(phone, '[^[:digit:]]', '', 'g') AS phone 
FROM user_contacts;

/* Запрос, который округлит даты в текстовом поле updated_at до первого дня месяца. Сначала преобразует поле к типу timestamp, 
а затем округлит значения до первого дня месяца и выведи только дату без времени. */

SELECT DATE_TRUNC('month', TO_TIMESTAMP(updated_at, 'HH24:MI:SS DD/MM/YYYY'))::DATE AS updated_month
FROM user_contacts;

/* Запрос добавит NOT NULL ограничение на колонку client_id в таблице user_contacts. */

ALTER TABLE user_contacts ALTER client_id SET NOT NULL;

/* запрос над таблицей user_activity_log, который вернёт три поля: 
	• client_id — идентификатор клиента;
	• month — месяц данных (должен иметь тип date);
	• visit_to_login_events — количество событий типа login, следующих сразу,
	без каких-либо промежуточных событий, после события visit за месяц.*/

SELECT client_id, DATE_TRUNC('month', hitdatetime)::DATE AS month, 
COUNT(CASE WHEN prev_action = 'visit' AND action = 'login' THEN 1 ELSE NULL END) AS visit_to_login_events 
FROM(SELECT *, LAG(action) OVER(PARTITION BY client_id ORDER BY hitdatetime)
AS prev_action FROM user_activity_log) AS ual
GROUP BY client_id, month;

/* запрос над таблицей user_payment_log, который вернёт 2 поля:
	1. client_id — идентификатор клиента;
	2. daily_actions_pct — процент действий клиента, совершённых в промежутке с 12 до 18 часов 
    (не включая правую границу 18:00), от всех действий клиента в таблице.
Считаем, что все клиенты находятся в одном часовом поясе и данные в базе соответствуют этому поясу. */

SELECT client_id, 
  COUNT(*) FILTER (WHERE EXTRACT(HOUR FROM hitdatetime) >= 12 
  AND EXTRACT(HOUR FROM hitdatetime) < 18) * 100.0 / COUNT(*) AS daily_actions_pct
FROM  user_payment_log GROUP BY client_id;

/* Проверьте корректность значений метрики visit_events — количество событий
 типа visit по каждому клиенту в месяц из таблицы user_activity_log.
	• visit_events_min — минимальное значение метрики;
	• visit_events_max — максимальное значение метрики;
	• visit_events_avg — среднее значение метрики;
	• visit_events_null — количество пустых значений метрики;
	• visit_events_zero — количество нулевых значений метрики;
	• visit_events_zero_pct — процент нулевых значений метрики по всей таблице;
visit_events_nonzero — количество ненулевых значений метрики. */

WITH cte AS (SELECT client_id, CAST(DATE_TRUNC('Month',hitdatetime) AS DATE) "month",
    COUNT(CASE WHEN "action" = 'visit' THEN 1 END) visit_events
FROM user_activity_log
WHERE EXTRACT(YEAR FROM hitdatetime) = 2021
GROUP BY client_id, CAST(DATE_TRUNC('Month',hitdatetime) AS DATE))

SELECT MIN(visit_events) AS visit_events_min, MAX(visit_events) AS visit_events_max, 
AVG(visit_events) AS visit_events_avg, COUNT(*) FILTER(WHERE visit_events IS NULL) AS visit_events_null, 
COUNT(*) FILTER(WHERE visit_events = 0) AS visit_events_zero, 
COUNT(*) FILTER(WHERE visit_events = 0) * 100.0 / COUNT(*) AS visit_events_zero_pct,
COUNT(*) - COUNT(*) FILTER(WHERE visit_events = 0) AS visit_events_nonzero
FROM cte;

/* создадим витрину данных - Запрос который создает таблицу с наименованием clients_cluster_metrics_m. Необходимые типы данных:
	• date для поля month;
	• bigint для client_id и всех целочисленных метрик;
	• varchar(30) для utm_campaign;
	• varchar(3) для reg_code;
	• double precision для вещественных метрик. */

CREATE TABLE IF NOT EXISTS clients_cluster_metrics_m(
month DATE, 
client_id BIGINT,
utm_campaign VARCHAR(30),
reg_code VARCHAR(3),
total_events BIGINT,
visit_events BIGINT,
registration_events BIGINT,
login_events BIGINT,
visit_to_login_events BIGINT,
total_pay_events BIGINT,
accepted_method_actions BIGINT,
made_payments BIGINT,
avg_payment DOUBLE PRECISION,
sum_payments DOUBLE PRECISION,
rejects_share DOUBLE PRECISION
);

/* Для таблицы clients_cluster_metrics_m ограничение: составной PRIMARY KEY 
с наименованием clients_cluster_metrics_m_month_client_id_pkey */

ALTER TABLE clients_cluster_metrics_m 
ADD CONSTRAINT clients_cluster_metrics_m_month_client_id_pkey
PRIMARY KEY (client_id, month);

/* для таблицы clients_cluster_metrics_m ограничение FOREIGN KEY 
с наименованием clients_cluster_metrics_m_client_id_fkey на поле client_id. 
Идентификаторы клиентов в поле client_id могут быть только из таблицы user_attributes. */

ALTER TABLE clients_cluster_metrics_m
ADD CONSTRAINT clients_cluster_metrics_m_client_id_fkey
FOREIGN KEY (client_id) 
REFERENCES user_attributes(client_id);

/* Убедимся, что индекс создался в PostgreSQL автоматически, 
запрос к таблице метаданных pg_indexes в схеме pg_catalog,
который выведет текст создания этого индекса для таблицы clients_cluster_metrics_m. */

SELECT indexdef
FROM pg_indexes
WHERE schemaname= 'public'
AND tablename= 'clients_cluster_metrics_m';

/* запрос, который наполнит данными таблицу clients_cluster_metrics_m */

INSERT INTO clients_cluster_metrics_m (
    month,
    client_id,
    utm_campaign,
    reg_code,
    total_events,
    visit_events,
    registration_events,
    login_events,
    visit_to_login_events,
    total_pay_events,
    accepted_method_actions,
    avg_payment,
    made_payments,
    sum_payments,
    rejects_share
)
WITH act_lg AS (
	SELECT date_trunc('month',hitdatetime)::DATE "month",
		client_id,
		COUNT(1) total_events,
		COUNT(CASE WHEN "action" = 'visit' THEN 1 END) visit_events,
		COUNT(CASE WHEN "action" = 'registration' THEN 1 END) registration_events,
		COUNT(CASE WHEN "action" = 'login' THEN 1 END) login_events,
		COUNT(CASE WHEN ("action" = 'login') AND (prev_action = 'visit') THEN 1 END) visit_to_login_events
	FROM (
		SELECT *,
			lag("action") OVER (PARTITION BY client_id ORDER BY hitdatetime) prev_action
		FROM user_activity_log
		WHERE extract(YEAR FROM hitdatetime) = 2021
			AND "action" != 'N/A'
		)t
	GROUP BY 1,2
	),
pmnts AS (
	SELECT date_trunc('month',hitdatetime)::DATE "month",
		client_id,
		COUNT(1) total_pay_events,
		COUNT(CASE WHEN "action" = 'accept-method' THEN 1 END) accepted_method_actions,
		COUNT(CASE WHEN "action" = 'make-payment' THEN 1 END) made_payments,
		AVG(CASE WHEN "action" = 'make-payment' THEN COALESCE(payment_amount,0) ELSE 0 END) avg_payment,
		SUM(CASE WHEN "action" = 'make-payment' THEN COALESCE(payment_amount,0) ELSE 0 END) sum_payments,
		SUM(CASE WHEN "action" = 'reject-payment' THEN COALESCE(payment_amount,0) ELSE 0 END)
			/ nullif(sum(CASE WHEN "action" = 'make-payment' THEN COALESCE(payment_amount,0) ELSE 0 END),0) rejects_share
	FROM user_payment_log
	WHERE extract(year FROM hitdatetime) = 2021
	GROUP BY 1,2
),
cntct AS (
SELECT DISTINCT ON (client_id) client_id,
	SUBSTR(REGEXP_REPLACE(phone,'[^0123456789]','','g'),2,3) AS reg_code
FROM user_contacts
ORDER BY client_id,created_at DESC 
)
SELECT COALESCE(a."month",p."month") "month",
	ua.client_id,
	ua.utm_campaign,
	c.reg_code,
	COALESCE(a.total_events,0) total_events,
	COALESCE(a.visit_events,0) visit_events,
	COALESCE(a.registration_events,0) registration_events,
	COALESCE(a.login_events,0) login_events,
	COALESCE(a.visit_to_login_events,0) visit_to_login_events,
	COALESCE(p.total_pay_events,0) total_pay_events,
	COALESCE(p.accepted_method_actions,0) accepted_method_actions,
	COALESCE(p.avg_payment,0) avg_payment,
	COALESCE(p.made_payments,0) made_payments,
	COALESCE(p.sum_payments,0) sum_payments,
	p.rejects_share
FROM act_lg a
FULL JOIN pmnts p ON p."month" = a."month"
				AND p.client_id = a.client_id
JOIN user_attributes ua ON ua.client_id = COALESCE(a.client_id,p.client_id)
LEFT JOIN cntct c ON c.client_id = ua.client_id
ORDER BY 1,2;

/* Проверьте глубину данных и наличие пробелов в них. Запрос к построенной витрине clients_cluster_metrics_m, 
который вернёт два поля:
	• month — месяц данных из витрины;
	• total_records — общее количество записей в этом месяце.
Отсортируем данные по убыванию значений поля month. */

SELECT month, COUNT(*) AS total_records FROM clients_cluster_metrics_m GROUP BY month ORDER BY month DESC;

/* Запрос, который вернёт два поля:
	• month — месяц данных из витрины;
	• rejects_share_empty_pct — процент случаев, когда поле rejects_share не заполнено. 
Ожидаемый формат данных в поле — число с плавающей запятой и 16 символами после запятой.
Отсортировать данные по убыванию значений поля month и не используйте CTE или подзапросы.*/

SELECT month, COUNT(CASE WHEN rejects_share IS NULL THEN 1 END) * 100 / COUNT(*)::DECIMAL(38,16) AS rejects_share_empty_pct 
FROM clients_cluster_metrics_m ccmm 
GROUP BY month
ORDER BY month DESC;



